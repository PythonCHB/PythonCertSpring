\documentclass{beamer}
%\usepackage[latin1]{inputenc}
\usetheme{Warsaw}
\title[Python Certificate: System Development]{System Development with Python: Week 1}
\author{Christopher Barker}
\institute{UW Continuing Education}
\date{March 26, 2013}

\usepackage{listings}
\usepackage{hyperref}

\begin{document}

% ---------------------------------------------
\begin{frame}
  \titlepage
\end{frame}

% ---------------------------------------------
\begin{frame}
\frametitle{Table of Contents}
%\tableofcontents[currentsection]
  \tableofcontents
\end{frame}


\section{Class Overview}

% ---------------------------------------------
\begin{frame}[fragile]{Class Structure}

{\Large
\vfill
\begin{itemize}
  \item Lecture
  \item Labs
  \item Summary
  \item Project time
\end{itemize}
}

\vfill

\end{frame}


\section{Testing}


% ---------------------------------------------
\begin{frame}[fragile]{Testing}

\vfill
{\Large I hope I don't need to tell you why testing is important}

\vfill
{\Large I'll focus on testing your Python code -- not another system}

\vfill
{\Large Mostly unit testing}

\vfill
{\Large And an introduction to some of the tools}

\vfill

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Python Testing Taxonomy}

\begin{enumerate}
  \item    Unit Testing Tools
  \item    Mock Testing Tools
  \item    Fuzz Testing Tools
  \item    Web Testing Tools
  \item    Acceptance/Business Logic Testing Tools
  \item    GUI Testing Tools
  \item    Source Code Checking Tools
  \item    Code Coverage Tools
  \item    Continuous Integration Tools
  \item    Automatic Test Runners
  \item    Test Fixtures
  \item    Miscellaneous Python Testing Tools
\end{enumerate}

\vfill
\url{http://wiki.python.org/moin/PythonTestingToolsTaxonomy}

\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{Testing}

\vfill
{\LARGE Regression Testing:}

\vfill
{\Large Regression testing is any type of software testing that seeks to
uncover new software bugs, or regressions, in existing functional and
non-functional areas of a system after changes}

\vfill
{\LARGE Unit Testing:}

\vfill
{\Large Unit testing is a method by which individual units of source code,
sets of one or more computer program modules together with associated control
data, usage procedures, and operating procedures, are tested to determine if
they are fit for use}

\vfill

\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{doctest}

{\LARGE￼doctest}

\vfill
{\Large \vspace{0.3in} -- In the stdlib}

\vfill
{\Large \vspace{0.3in} -- Unique to Python?}

\vfill
{\Large \vspace{0.3in} -- Literate programming}

\vfill
{\Large \vspace{0.3in} -- Verify examples in the docs}

\vfill
\url{http://docs.python.org/library/doctest.html}


\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{doctest example}


\begin{verbatim}
def get_the_answer():
    """
    get_the_answer() -> return the answer to everything
    
    >>> print get_the_answer()
    42
    """
    return 42
\end{verbatim}

(\verb|code/the_answer.py|)

\vfill
{\Large An exact dump of the command line output}

\vfill
\url{http://docs.python.org/library/doctest.html}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{doctest uses}

{\large
``
As mentioned in the introduction, doctest has grown to have three primary uses:

\begin{itemize}
    \item Checking examples in docstrings.
    \item Regression testing.
    \item Executable documentation / literate testing.
\end{itemize}

These uses have different requirements, and it is important to distinguish them.
In particular, filling your docstrings with obscure test cases makes for bad
documentation.''
}

\vfill
\url{http://docs.python.org/library/doctest.html}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{running doctests}

{\Large In \verb|__name__ == "__main__"| block:}

\vfill
\begin{verbatim}
if __name__ == "__main__":
    import doctest
    doctest.testmod()
\end{verbatim}

\vfill
{\large (Tests the current module) }


\vfill
\url{http://docs.python.org/library/doctest.html}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{running doctests}

\vfill
{\Large In an external file:}

\begin{verbatim}
    doctest.testfile("name_of_test_file.txt")
\end{verbatim}

{\large Tests the docs in the file (ReSt format...) }


\vfill
{\large With a test runner: more on that later}

\vfill
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{running doctests}

\vfill
{\large In a documentation system:}

\vfill
{\LARGE Sphinx:}

\vfill
{\Large Sphinx is a tool that makes it easy to create intelligent and beautiful documentation}

\vfill
{\Large -- Lots of output options: html, pdf, epub, etc, etc...}

\vfill
{\Large -- Can auto-generate docs from docstrings}

\vfill
{\Large -- And run the doctests}

\vfill
\url{http://sphinx.pocoo.org/}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Code Checking}

{\LARGE Not Really testing, but...}

\vfill
{\LARGE pychecker}\\
\url{http://pychecker.sourceforge.net/}

\vfill
{\LARGE pylint}\\
\url{http://www.logilab.org/857/}

\vfill
{\LARGE pyflakes}\\
\url{http://pypi.python.org/pypi/pyflakes}

\vfill
{\Large Will help you keep your source code clean}

\end{frame} 

%-------------------------------
\begin{frame}[fragile]{Coding Style}

{\Large Coding style really helps readability}

Keep it consistent within your project

\vfill

{\Large Options:}
\begin{itemize}
  \item Your company style guide

  \item PEP 8 \\
        \url{http://www.python.org/dev/peps/pep-0008/}

  \item Another Established Style (Google's is pretty good) \\
        \url{http://google-styleguide.googlecode.com/svn/trunk/pyguide.html}
\end{itemize}

\end{frame} 

%-------------------------------
\begin{frame}[fragile]{Coding Style}


{\LARGE￼\verb|pep8.py|}

\vfill
{\Large Tells you when you have code \\
        that doesn't follow PEP 8}

\vfill
{\large \verb| pip install pep8 | }

\vfill
\url{http://pypi.python.org/pypi/pep8/}

\end{frame} 



%-------------------------------
\begin{frame}[fragile]{LAB}

{\Large doctests:}

\begin{itemize}
  \item doctest
    \begin{itemize}
       \item Add doctests to the Circle class in the code dir
       \item Run it from the \verb|if __name__ == "__main__"| clause\\
             (\verb|code\circle.py|)
    \end{itemize}
  \item Code style
    \begin{itemize}
       \item Try running \verb|pylint, pychecker or pyflakes| on it 
       \item Run pep8 on it
       \item (or your own code)
    \end{itemize}

\end{itemize}

\end{frame}

\section{Unit Testing}

% ---------------------------------------------
\begin{frame}[fragile]{Unit Testing}

{\LARGE Gaining Traction}

\vfill
{\Large You need to test your code when you write it -- why not preserve those tests?}

\vfill
{\Large And allow you to auto-run them later?}

\vfill
{\LARGE Test-Driven development:}\\[0.1in]
{\Large \hspace{0.3in} Write the tests before the code}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Unit Testing}

{\LARGE My thoughts:}

\vfill
{\Large Unit testing encourages clean, decoupled design}

\vfill
{\Large If it's hard to write unit tests for -- it's not well designed}

\vfill
{\Large but...}

\vfill
{\Large ``complete'' test coverage is a fantasy}

\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{PyUnit}

{\LARGE PyUnit: the stdlib unit testing framework}

\vfill
{\Large \verb|import unittest|}

\vfill
{\Large More or less a port of Junit from Java}

\vfill
{\Large A bit verbose: you have to write classes \& methods}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{unittest example}

{\small
\begin{verbatim}
import random
import unittest

class TestSequenceFunctions(unittest.TestCase):

    def setUp(self):
        self.seq = range(10)

    def test_shuffle(self):
        # make sure the shuffled sequence does not lose any elements
        random.shuffle(self.seq)
        self.seq.sort()
        self.assertEqual(self.seq, range(10))

        # should raise an exception for an immutable sequence
        self.assertRaises(TypeError, random.shuffle, (1,2,3))
\end{verbatim}
}

\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{unittest example (cont)}

{\small
\begin{verbatim}
    def test_choice(self):
        element = random.choice(self.seq)
        self.assertTrue(element in self.seq)

    def test_sample(self):
        with self.assertRaises(ValueError):
            random.sample(self.seq, 20)
        for element in random.sample(self.seq, 5):
            self.assertTrue(element in self.seq)

if __name__ == '__main__':
    unittest.main()
\end{verbatim}
}

\vfill
(\verb|code/unitest_example.py|)

\vfill
\url{http://docs.python.org/library/unittest.html}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{unittest}

{\Large Lots of good tutorials out there:}

\vfill
{\Large Google: ``python unittest tutorial''}

\vfill
{\Large I first learned from this one:}\\[0.1in]
\url{http://www.diveintopython.net/unit_testing/index.html}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{nose and pytest}

{\Large Due to its Java heritage, unittest is kind of verbose}

\vfill
{\Large Also no test discovery}\\
\hspace{0.2in}(though unittest2 does add that...)

\vfill
{\Large So folks invented nose and pytest}

\end{frame} 

\begin{frame}[fragile]{nose}

{\LARGE \verb|nose|}

\vfill
{\Large \hspace{0.2in} Is nicer testing for python}

\vfill
{\Large \hspace{0.2in} nose extends unittest to make testing easier.}

\vfill
\begin{verbatim}
 $ pip install nose

 $ nosetests unittest_example.py 
\end{verbatim}

\vfill
\url{http://nose.readthedocs.org/en/latest/}
\end{frame} 

\begin{frame}[fragile]{nose example}

{\Large The same example -- with nose}

{\small
\begin{verbatim}
import random
import nose.tools

seq = range(10)

def test_shuffle():
    # make sure the shuffled sequence does not lose any elements
    random.shuffle(seq)
    seq.sort()
    assert seq == range(10)

@nose.tools.raises(TypeError)
def test_shuffle_immutable():
    # should raise an exception for an immutable sequence
    random.shuffle( (1,2,3) )
\end{verbatim}
}

\end{frame} 

\begin{frame}[fragile]{nose example (cont) }

{\small
\begin{verbatim}
def test_choice():
    element = random.choice(seq)
    assert (element in seq)

def test_sample():
    for element in random.sample(seq, 5):
        assert element in seq

@nose.tools.raises(ValueError)
def test_sample_too_large():
    random.sample(seq, 20)
\end{verbatim}
}

\vfill
(\verb|code/test_random_nose.py|)

\end{frame} 


\begin{frame}[fragile]{pytest}

{\LARGE \verb|pytest|}

\vfill
{\Large \hspace{0.2in} A mature full-featured testing tool}

\vfill
{\Large \hspace{0.2in} Provides no-boilerplate testing}

\vfill
{\Large \hspace{0.2in} Integrates many common testing methods}

\vfill
\begin{verbatim}
 $ pip install pytest

 $ py.test unittest_example.py 
\end{verbatim}

\vfill
\url{http://pytest.org/latest/}
\end{frame} 

\begin{frame}[fragile]{pytest example}

{\Large The same example -- with pytest}

{\small
\begin{verbatim}
import random
import pytest

seq = range(10)

def test_shuffle():
    # make sure the shuffled sequence does not lose any elements
    random.shuffle(seq)
    seq.sort()
    assert seq == range(10)

def test_shuffle_immutable():
    pytest.raises(TypeError, random.shuffle,  (1,2,3) )
\end{verbatim}
}

\end{frame} 

\begin{frame}[fragile]{pytest example (cont) }

{\small
\begin{verbatim}
def test_choice():
    element = random.choice(seq)
    assert (element in seq)

def test_sample():
    for element in random.sample(seq, 5):
        assert element in seq

def test_sample_too_large():
    with pytest.raises(ValueError):
        random.sample(seq, 20)
\end{verbatim}
}

\vfill
(\verb|code/test_random_pytest.py|)

\end{frame} 

\begin{frame}[fragile]{A Diversion:}

{\LARGE Context Managers:} {\Large the \verb|with| statement}

\vfill
{\Large A class with \verb|__enter__()| and \verb|__exit__()| methods.}
 
\vfill
{\Large \verb|__enter__()| is run before your block of code}

\vfill
{\Large \verb|__exit__()| is run after your block of code}

\vfill
{\Large Can be used to setup/cleanup before and after: open/closing files, db connections, etc}
\end{frame} 

\begin{frame}[fragile]{A Diversion }

{\Large ``PEP 343: the \verb|with| statement''} \\
\hspace{0.2in}  -- A.M. Kuchling

\url{http://docs.python.org/dev/whatsnew/2.6.html#pep-343-the-with-statement}

\vfill
{\Large ``Understanding Python's \verb|with| statement''} \\
\hspace{0.2in}  -- Fredrik Lundh 

\url{http://effbot.org/zone/python-with-statement.htm}

\vfill
{\Large ``The Python \verb|with| Statement by Example''} \\
\hspace{0.2in}  -- Jeff Preshing 

\url{http://preshing.com/20110920/the-python-with-statement-by-example}

\end{frame} 

\begin{frame}[fragile]{Parameterized Tests}

{\Large A whole set of inputs and outputs to test?}

\vfill
{\Large \verb|pytest| has a nice way to do that (so does nose...)}

\begin{verbatim}
import pytest
@pytest.mark.parametrize(("input", "expected"), [
    ("3+5", 8),
    ("2+4", 6),
    ("6*9", 42),
])
def test_eval(input, expected):
    assert eval(input) == expected
\end{verbatim}

\url{http://pytest.org/latest/example/parametrize.html}

\vfill
(\verb|code/test_pytest_parameter.py|)
\end{frame} 

\begin{frame}[fragile]{Test Coverage}

{\LARGE \verb|￼coverage.py |}

\vfill
{\Large Uses debugging hook to see which lines of code are actually executed
-- plugins exist for most (all?) test runners}

\vfill
{\Large \verb|￼pip install coverage |}

\vfill
{\Large \verb|￼nosetests --with-coverage test_codingbat.py|}

\vfill
\url{http://nedbatchelder.com/code/coverage/}
\end{frame}

% --------------------------
\begin{frame}[fragile]{Coding Bat}

{\LARGE Coding Bat:}

\url{http://codingbat.com/python}

\vfill
{\Large Quicky little code excercises}

\vfill
{\Large Tells you what unit tests to write:}

\url{http://codingbat.com/prob/p118406}

\vfill
{\Large We'll use them for our lab}

\vfill
{\large ...and you might want to do a few for practice anyway...}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{LAB}

{\Large Unit Testing:}

\begin{itemize}
  \item unittest
    \begin{itemize}
       \item Pick a \url{codingbat.com} example
       \item Write a set of unit tests using \verb|unittest|
         (\verb|code\codingbat.py  codingbat_unittest.py|)
    \end{itemize}
  \item pytest / nose
    \begin{itemize}
       \item Test a \url{codingbat.com} with nose or pytest
       \item Try doing test-driven development
         (\verb|code\test_codingbat.py|)
    \end{itemize}

  \item try running your circle doctest with nose, pytest\\
        (and/or add doctests to your codingbat example)
  \item try running \verb|coverage| on your tests
\end{itemize}

\end{frame}

\section{Packaging Your Stuff}

\begin{frame}[fragile]{Distributing}

{\LARGE What if you need to distribute you own code?}

\vfill
{\Large Scripts}

\vfill
{\Large Libraries }

\vfill
{\Large Applications }
\vfill

\end{frame} 

\begin{frame}[fragile]{Scripts}

\vfill
{\LARGE Often you can just copy, share, or check in the script to source
control and call it good.}

\vfill
{\large (But only if it's a single file, and doesn't need anything non-standard) }
\end{frame} 

\begin{frame}[fragile]{Scripts}

\vfill
{\LARGE ￼When the script needs more than just the stdlib (or your company standard environment)}

\vfill
{\LARGE You have an application, not a script}

\vfill

\end{frame} 

\begin{frame}[fragile]{Libraries}

\vfill
{\LARGE When you read the distutils docs, it's usually libraries they're talking about}


\vfill
{\LARGE Scripts + library is the same...}


\vfill
(\url{http://docs.python.org/distutils/})
\end{frame} 

\begin{frame}[fragile]{distutils}

\vfill
{\LARGE \verb|distutils| makes it easy to do the easy stuff:}

\vfill
{\Large Distribute and install to multiple platforms, etc.}

\vfill
{\Large Even binaries, installers and compiled packages}

\vfill
{\Large (Except dependencies)}

\vfill
(\url{http://docs.python.org/distutils/})
\end{frame} 

\begin{frame}[fragile]{distutils basics}

\vfill
{\Large It's all in the \verb|setup.py file|:}

\begin{verbatim}
from distutils.core import setup
setup(name='Distutils',
      version='1.0',
      description='Python Distribution Utilities',
      author='Greg Ward',
      author_email='gward@python.net',
      url='http://www.python.org/sigs/distutils-sig/',
      packages=['distutils', 'distutils.command'],
     )
\end{verbatim}
\vfill
(\url{http://docs.python.org/distutils/})
\end{frame} 

\begin{frame}[fragile]{distutils basics}

{\Large Once your setup.py is written, you can:}

\begin{verbatim}
python setup.py ...

build         build everything needed to install
install       install everything from build directory
sdist         create a source distribution
              (tarball, zip file, etc.)
bdist         create a built (binary) distribution
bdist_rpm     create an RPM distribution
bdist_wininst create an executable installer for MS Windows
upload        upload binary package to PyPI
\end{verbatim}

\end{frame} 

%----------------------------------------------
\begin{frame}[fragile]{More Complex Packaging}

{\Large For a complex package:}

\vfill
{\Large You want to use a well structured setup:}

\vfill
\url{http://guide.python-distribute.org/creation.html}
\vfill
\end{frame} 

%----------------------------------------------
\begin{frame}[fragile]{Package Structure}

\begin{verbatim}
ProjectName/
    scripts/
    CHANGES.txt
    docs/
    LICENSE.txt
    setup.py
    project_package/
       __init__.py
      module1.py
      module2.py
    tests/
      test_module1.py
      test_module2.py
\end{verbatim}

\end{frame}

%----------------------------------------------
\begin{frame}[fragile]{develop mode}

{\Large While you are developing your package, Installing it is a pain.}

\vfill
{\Large But you want your code to be able to import, etc. as though it were installed.}

\vfill
{\Large \verb|setup.py develop|
\vfill
installs links to your code, rather than copies
   -- so it looks like it's installed, but it's using the original source}

\vfill
{\Large You need \verb|distribute| (or \verb|setuptools|) to use it.}
\vfill
\end{frame} 

%----------------------------------------------
\begin{frame}[fragile]{Applications}

{\Large For a complete application:}
\begin{itemize}
  \item Web apps
  \item GUI apps
\end{itemize}

{\Large Multiple options:}
\begin{itemize}
  \item Virtualenv + RCS
  \item zc.buildout ( \url{http://www.buildout.org/} )
  \item System packages (rpm, deb, ...)
  \item Bundles...
\end{itemize}

\end{frame} 

%----------------------------------------------
\begin{frame}[fragile]{Bundles}

{\Large
Bundles are Python + all your code + plus all the dependencies --
all in one single ``bundle'' 

\vfill
Most popular on Windows and OS-X
}
\begin{verbatim}
  py2exe
  py2app
  pyinstaller
 ...
\end{verbatim}

{\Large User doesn't even have to know it's python }

\vfill
Examples: \\
\hspace{0.5in} \url{http://www.bitpim.org/} \\
\hspace{0.5in} \url{http://response.restoration.noaa.gov/nucos}

\end{frame} 



%-------------------------------
\begin{frame}[fragile]{Wrap up}

\vfill
{\Large Hopefully you've got a bit of an idea how to do\\[0.1in]
        unit testing in Python.}

\vfill
{\Large And will now start doing it.}

\vfill
{\Large And an idea how to set up your package...}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Next Week:}

\vfill
{\LARGE The python debugger pdb}

\vfill
{\Large  -- Jeff}

\vfill
{\Large And of course, your projects...}

\vfill

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Homework}

For the entire quarter, your homework is to work on your projects

For next week:

\begin{itemize}
    \item Set up the package structure
    \item Put it in gitHub (or some RCS)
    \item Map out the design
    \item Determine major third party packages you will need.
    \item Write a few unit tests (even if they all fail!)
\end{itemize}

\end{frame}

%-------------------------------
\begin{frame}[fragile]{Project Time!}

\begin{itemize}
    \item Do you have a project? 
    \item Do you have a team?
    \item Do you know what modules you'll need?
    \item Let's get to work!
\end{itemize}

\end{frame}

\end{document}

 
